# Automation âš™ï¸

The `packages/@registries` folder contains the results of all the automation scripts defined at `packages/@aetherspace/scripts`.

These scripts are automatically run in development mode from the `withAutomation()` plugin in `apps/next/next.config.js`.

Alternatively, you can run the automation scripts manually from the root of the project:

```bash
yarn collect-assets # runs `packages/@aetherspace/scripts/collect-assets.js`
yarn collect-resolvers # runs `packages/@aetherspace/scripts/collect-resolvers.js`
yarn document-components # runs `packages/@aetherspace/scripts/document-components.js`
```

## Automagic Storybook docgen âœ¨

The `packages/@registries/docs` folder contains automatically generated `.stories.mdx` files for all the components hooking into the automation.

```bash
yarn document-components
```

**Enable automatic documentation for your component by:**

1. Making sure your component filename ends in `.tsx`
2. Providing a named or default export matching the filename
3. Component defines its prop structure or types with `aetherspace/schema`
4. File exports a `getDocumentationProps` schema object

`next.config.js`

```js
const withAutomation = () => {
    // -i- Clear out previously autogenerated docs folder so it can be rebuilt from scratch
    require('aetherspace/scripts/documentation-reset')
    // -i- Autogenerate documentation for all components hooking into the automation script
    // -i- Enable by exporting a 'getDocumentationProps' object or function from a component
    require('aetherspace/scripts/document-components')
}
```


## GraphQL from the filesystem ðŸ“

The `resolvers.generated.ts` file contains a modularised list of all API resolvers hooking into this automation.

The `collect-resolvers` script builds this barrel module by analysing all api handlers matching `/apps/next/**/api/**/*.ts`.

```bash
yarn collect-resolvers
```

The generated barrel file is then used in our graphql API route to hook up the resolvers to the Apollo GraphQL server, essentially _generating a GraphQL schema and API from the filesystem_.

**The script only picks up resolvers that:**
- use `aetherspace/schema`
- are located in `apps/next/**/api/**/*.ts`
- wrap their resolver function with `aetherResolver()`

`next.config.js`

```js
const withAutomation = () => {
    // -i- Build 'packages/@registries/resolvers.generated.ts':
    // -i- Turns all REST api paths built with aetherResolver into GraphQL resolvers as well
    require('aetherspace/scripts/collect-resolvers')
}
```

## Relative 'src' strings ðŸ“¸

The `assets.generated.ts` file contains a modularised list of all assets located under `apps/next/public/` folder.

The `collect-assets` script turns the img file paths into export keys for those resources.

```bash
yarn collect-assets
```

Our expo app then supplies this barrel module of assets to the `AetherContextManager` so that the `AetherImage` primitive can use it to resolve the assets. This enables `AetherImage` to use the `src` prop with relative paths the same way an `img` tag would.

**To hook into this automation:**

1. Add any assets to `apps/next/public/**/*`
2. Ensure the following is uncommented or present in your next.js config

`next.config.js`

```js
const withAutomation = () => {
    // -i- Build 'packages/@registries/assets.generated.ts':
    // -i- Makes regular img src paths like on the web work for AetherImage in Expo
    require('aetherspace/scripts/collect-assets')
}
```

## Explaining the magic

Most of these scripts contain of 2 steps to create their results:
1. Collect all relevant filePaths with `glob`
2. Analyse, filter & generate template code from their file contents
